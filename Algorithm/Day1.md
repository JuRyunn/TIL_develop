## 알고리즘
- 알고리즘은 여러가지 방법으로 표현가능.
- 하나의 문제를 해결하기 위해 여러가지 알고리즘이 가능하다.
- 동일한 문제에 대해 매우 다른 전략을 기반으로 알고리즘 작성이 가능하고 이들은 매우 다른 속도로 문제 해결이 가능하다.
- 알고리즘의 정확한 동작을 위한 제한조건, 입력의 범위를 신중하게 작성해야한다.

<br>

## 알고리즘의 조건
- 입력: 알고리즘이 입력을 받으면 보호하지 않고 잘 정의된 입력이 있어야한다. 알고리즘은 0개 이상의 입력을 가진다.
- 출력: 출력은 명확하게 정의되어야하며 1개 이상의 출력이 반드시 존재해야한다.
- 명확성: 각 명령어의 의미는 보호하지 않고 명확해야한다.
- 유한성: 한정된 수의 단계 후에는 반드시 종료되어야한다. 즉, 무한루프나 이와 유사한 상태로 끝나서는 안된다.
- 유효성: 명령어들은 현재 실행 가능한 연산이어야한다. 미래에 개발될 기술을 포함해서는 안된다.

<br>

## 알고리즘의 기술
##### 1. 영어나 한국어와 같은 자연어를 사용하는 방법
```
find_max(A)
I. 리스트 A의 첫번째 항목을 변수 max에 복사한다.
II. 리스트 A의 다음 항목들을 차례대로 max와 비교하며 max보다 더 크면 그 값을 max로 복사한다.
III. 바열 A의 모든 요소를 비교했으면 max를 반환한다.
```

##### 2. 흐름도로 표시하는 방법
![image](https://user-images.githubusercontent.com/79950504/188528493-b78628c5-e16b-43b5-afb5-5cd41f833d63.png)


##### 3. 유사코드로 기술하는 방법
```
find_max(A)
  max ← A[0] // ← : 대입연산
  for i ← 1 to size(A) do
    if A[i] > max then
      max ← A[i]
  return
```

##### 4. 특정 프로그래밍 언어로 기술하는 방법
```C
// c언어
int find_max(int A[], int n) { // 배열의 길이 전달해야함.
  int i, tmp= A[0]; // 사용할 변수를 미리 선언해야함.
  for(i=1; i<n; i++) {
    if(A[i] > tmp) { 
      tmp= A[i]; // =을 대입연산자 사용, 비교 연산자는 ==
    } 
  }
  return tmp;
}
```

<br>

## 예제: 최대공약수
#### 1: 정의를 직접 이용
- 60의 약수: 1 2 3 4 5 6 10 12 15 20 30
- 28의 약수: 1 2 4 7 14
- 공통 약수: 1 2 4
- 최대 공약수: 4
``` 
gcd (a, b)
I. a의 약수를 모두 찾아 리스트 A_list에 저장.
II. b의 약수를 모두 찾아 리스트 B_list에 저장.
III. A_list와 B_list에 공톡으로 들어 있는 가장 큰 수를 찾아 반환.
```

#### 2: 한 수의 약수만 구함
- 60의 약수: 1 2 3 4 5 6 10 12 15 20 30
- 28을 68의 약수로 나눈 나머지 (28% 약수): 0 3 4 8 4 13 8 28
- 나누어 떨어지는 가장 큰 약수: 4
``` 
gcd(a, b)
I. a의 약수를 모두 찾아 리스트 A_list에 저장한다.
II. A_list의 가장 큰 수부터 차례대로 b의 약수인지 검사한다. 만약 b의약수이기도 하면 이 숫자를 반환한다.
III. 이 과정을 A_list의 모든 숫자에 대해 반복한다.
```

#### 3: 유클리드 알고리즘
- gcd(a, b)= gcd(b, a mod b)
ex: gcd(60, 28) 60을 28로 나눈 나머지는 4
= gcd(28, 4) 28을 4로 나눈 나머지는 0
= gcd(4, 0) 작은 수가 0이 되면 큰 수가 최대 공약수
```python
def gcd(a, b): # a가 b보다 작지 않아야함.
  while b != 0: # b가 0이 아닐때까지
    r= a%b
    a= b
    b= r
  return a
```

<br>

## 문제해결과정
#### 알고리즘 개발 과정
![image](https://user-images.githubusercontent.com/79950504/188534438-ecfb8c30-49c1-47e7-b8f9-63e217b27253.png)

## 개발 방향 결정과 알고리즘의 설계
#### 알고리즘 설계 전 결정 사항
- 순서적(sequential) 알고리즘 / 병렬처리 (parallel) 알고리즘 
- 최적해와 근사해

#### 근사 알고리즘 고려해야하는 상황
- 많은 사례에 대해 정확한 해를 구할 수 없는 경우 (ex: 2의 제곱근)
- 계산량이 많아 현실적인 시간이 불가능한 경우
- 알고리즘의 중간 단계에서 사용되는 경우

<br>

## 알고리즘의 설계 기법
- 억지(brute - force) 기법과 완전 탐색
- 축소정복 (decrease - and - conqure)
- 분할정복 (divide - and conquer)
- 공간을 이용해 시간을 버는 전략
- 동적 계획법 (divide - and conquer)
- 탐욕적(greedy) 기법
- 백트랙킹과 분기 한정 기법


## 알고리즘의 정확성
#### 실험적 분석 (Experimental analysis, testing)
- 다양한 입력 적용.
- 충분한 테스트가 어느정도인지 애매함.
- 알고리즘이 틀렸다는 것을 보여주기 위해 한가지 입력 사례로도 충분.

#### 증멱적 분석 (Formal analysis, proving)
- 수학적인 증명.
- 수학적 귀납법(math analysis, proving).
- 증명이 매우 어려울 가능성 있음.

## 알고리즘의 분석과 구현
#### 알고리즘의 효율성 분석
- 시간 / 공간 / 코드 효율성

#### 알고리즘 구현
- 특정 프로그래밍 언어
- 컴파일 / 



