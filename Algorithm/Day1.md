## 알고리즘
- 알고리즘은 여러가지 방법으로 표현가능.
- 하나의 문제를 해결하기 위해 여러가지 알고리즘이 가능하다.
- 동일한 문제에 대해 매우 다른 전략을 기반으로 알고리즘 작성이 가능하고 이들은 매우 다른 속도로 문제 해결이 가능하다.
- 알고리즘의 정확한 동작을 위한 제한조건, 입력의 범위를 신중하게 작성해야한다.

<br>

## 알고리즘의 조건
- 입력: 알고리즘이 입력을 받으면 보호하지 않고 잘 정의된 입력이 있어야한다. 알고리즘은 0개 이상의 입력을 가진다.
- 출력: 출력은 명확하게 정의되어야하며 1개 이상의 출력이 반드시 존재해야한다.
- 명확성: 각 명령어의 의미는 보호하지 않고 명확해야한다.
- 유한성: 한정된 수의 단계 후에는 반드시 종료되어야한다. 즉, 무한루프나 이와 유사한 상태로 끝나서는 안된다.
- 유효성: 명령어들은 현재 실행 가능한 연산이어야한다. 미래에 개발될 기술을 포함해서는 안된다.

<br>

## 알고리즘의 기술
##### 1. 영어나 한국어와 같은 자연어를 사용하는 방법
```
find_max(A)
I. 리스트 A의 첫번째 항목을 변수 max에 복사한다.
II. 리스트 A의 다음 항목들을 차례대로 max와 비교하며 max보다 더 크면 그 값을 max로 복사한다.
III. 바열 A의 모든 요소를 비교했으면 max를 반환한다.
```

##### 2. 흐름도로 표시하는 방법
![image](https://user-images.githubusercontent.com/79950504/188528493-b78628c5-e16b-43b5-afb5-5cd41f833d63.png)


##### 3. 유사코드로 기술하는 방법
```
find_max(A)
  max ← A[0] // ← : 대입연산
  for i ← 1 to size(A) do
    if A[i] > max then
      max ← A[i]
  return
```

##### 4. 특정 프로그래밍 언어로 기술하는 방법
```C
// c언어
int find_max(int A[], int n) { // 배열의 길이 전달해야함.
  int i, tmp= A[0]; // 사용할 변수를 미리 선언해야함.
  for(i=1; i<n; i++) {
    if(A[i] > tmp) { 
      tmp= A[i]; // =을 대입연산자 사용, 비교 연산자는 ==
    } 
  }
  return tmp;
}
```

<br>

## 예제: 최대공약수
#### 1: 정의를 직접 이용
- 60의 약수: 1 2 3 4 5 6 10 12 15 20 30
- 28의 약수: 1 2 4 7 14
- 공통 약수: 1 2 4
- 최대 공약수: 4
``` 
gcd (a, b)
I. a의 약수를 모두 찾아 리스트 A_list에 저장.
II. b의 약수를 모두 찾아 리스트 B_list에 저장.
III. A_list와 B_list에 공톡으로 들어 있는 가장 큰 수를 찾아 반환.
```

#### 2: 한 수의 약수만 구함
- 60의 약수: 1 2 3 4 5 6 10 12 15 20 30
- 28을 68의 약수로 나눈 나머지 (28% 약수): 0 3 4 8 4 13 8 28
- 나누어 떨어지는 가장 큰 약수: 4
``` 
gcd(a, b)
I. a의 약수를 모두 찾아 리스트 A_list에 저장한다.
II. A_list의 가장 큰 수부터 차례대로 b의 약수인지 검사한다. 만약 b의약수이기도 하면 이 숫자를 반환한다.
III. 이 과정을 A_list의 모든 숫자에 대해 반복한다.
```

#### 3: 유클리드 알고리즘
- gcd(a, b)= gcd(b, a mod b)
ex: gcd(60, 28) 60을 28로 나눈 나머지는 4
= gcd(28, 4) 28을 4로 나눈 나머지는 0
= gcd(4, 0) 작은 수가 0이 되면 큰 수가 최대 공약수
```python
def gcd(a, b): # a가 b보다 작지 않아야함.
  while b != 0: # b가 0이 아닐때까지
    r= a%b
    a= b
    b= r
  return a
```

<br>

## 문제해결과정
#### 알고리즘 개발 과정
![image](https://user-images.githubusercontent.com/79950504/188534438-ecfb8c30-49c1-47e7-b8f9-63e217b27253.png)

## 개발 방향 결정과 알고리즘의 설계
#### 알고리즘 설계 전 결정 사항
- 순서적(sequential) 알고리즘 / 병렬처리 (parallel) 알고리즘 
- 최적해와 근사해

#### 근사 알고리즘 고려해야하는 상황
- 많은 사례에 대해 정확한 해를 구할 수 없는 경우 (ex: 2의 제곱근)
- 계산량이 많아 현실적인 시간이 불가능한 경우
- 알고리즘의 중간 단계에서 사용되는 경우

<br>

## 알고리즘의 설계 기법
- 억지(brute - force) 기법과 완전 탐색
- 축소정복 (decrease - and - conqure)
- 분할정복 (divide - and conquer)
- 공간을 이용해 시간을 버는 전략
- 동적 계획법 (divide - and conquer)
- 탐욕적(greedy) 기법
- 백트랙킹과 분기 한정 기법

<br>

## 알고리즘의 정확성
#### 실험적 분석 (Experimental analysis, testing)
- 다양한 입력 적용.
- 충분한 테스트가 어느정도인지 애매함.
- 알고리즘이 틀렸다는 것을 보여주기 위해 한가지 입력 사례로도 충분.

#### 증명적 분석 (Formal analysis, proving)
- 수학적인 증명.
- 수학적 귀납법(math analysis, proving).
- 증명이 매우 어려울 가능성 있음.

<br>

## 알고리즘의 분석과 구현
#### 알고리즘의 효율성 분석
- 시간 / 공간 / 코드 효율성.

#### 알고리즘 구현
- 특정 프로그래밍 언어.
- 컴파일 / 인터프리터.


<br>

## 문제 유형
#### 정렬
- 데이터를 순서대로 재배열하는 작업.
- 오름차순 / 내림차순.
- 레코드, 정렬키.
- 비교기반 / 분배기반.
- 안정성 만족 / 불만족.
- 제자리 정렬.

#### 탐색
- 원하는 값을 가진 레코드를 찾는 작업.
- 탐색키.
- 순차 탐색 / 이진탐색 / 해싱.

#### 문자열 처리
- 문자열은 문자들의 시퀸스.
- 텍스트 문자열 / 비트 문자열 / 유전 시퀸스 등...
- 문자열 매칭.

#### 그래프 문제
- 연결된 객체들 사이의 관계를 표현할 수 있는 자료구조.
- 다양한 객체들이 서로 복잡하게 연결된 구조표현.
- 다양한 문제들 ( 순회 / 위상정렬 / 최단경로 / 최소비용의 신장 트리 / TSP / Graph Coloring )

#### 조합문제
- 어떤 조건을 만족하는 순열이나 조합 또는 부분집합과 같은 조합 객체를 찾는 문제.
- 조합 객체의 수가 문제의 크기에 따라 매우 빠르게 증가.

#### 기하학적 문제
- 고대의 그리스인들.
- 최근접 쌍의 거리 문제.
- 컨벡스 헐.
- 계산 기하학.

<br>

## 자료구조 
- 자료들을 정리하고 조직화하는 여러가지 구조.
- 알고리즘의 설계에 큰 영향을 미침.
- 단순 자료구조 / 복합 자료구조.

#### 배열 구조와 연결된 구조
![image](https://user-images.githubusercontent.com/79950504/188535918-2484a899-9d68-4181-b024-7831e596f9a3.png)
- 직접 접근 / 순서 접근
- 파이썬에서 배열: List와 Tuple로 구현 가능.

<br>

## 리스트
- 항목들이 순서대로 나열, 각 항목들은 위치를 가짐.  
![image](https://user-images.githubusercontent.com/79950504/188536126-879dc9b7-9db8-4973-961f-7566bb7c9652.png)  
#### 파이썬에서 리스트가 필요한 경우
- 파이썬의 리스트 사용.
- 자료구조 리스트를 배열 구조로 구현한 클래스.

<br>

## 스택
![image](https://user-images.githubusercontent.com/79950504/188536218-a9000f3a-4c23-4110-8d48-b1b063e202da.png)
- 후입선출 (LIFO: Last In First Out)
#### 파이썬에서 스택이 필요한 경우
- 파이썬 리스트 이용.
- 큐 모듈의 LifoQueue 클래스 사용.
- 직접 클래스로 구현.

<br>

## 큐
![image](https://user-images.githubusercontent.com/79950504/188536447-fba711a1-121d-4987-a8f2-10c18751cc08.png)
- 선입선출(FIFO: Fist In First Out)
#### 파이썬에서 큐가 필요한 경우
- 큐 모듈의 Queue 클래스 사용.
- 직접 클래스로 구현.

#### 우선순위 큐
![image](https://user-images.githubusercontent.com/79950504/188536635-0c2a5b3c-bd6b-4689-8103-2863b6291531.png)
- 우선순위의 개념을 큐에 도입한 자료구조.
- 선형 자료구조가 아니다.
- 힙이 가장 효율적인 구현 방법이다.
- 힙큐 모듈을 사용해 파이썬에서 사용한다.

<br>

## 그래프 용어
![image](https://user-images.githubusercontent.com/79950504/188536976-ac9e0a97-f345-422c-ad29-22c1e5760f3a.png)
- 인접 정점 (adjacent vertex)
- 정점의 차수 (진입차수 / 진출차수)
- 경로
- 경로의 길이
- 단순경로 / 사이클
- 연결 그래프
- 트리
- 완전 그래프

#### 그래프의 표현
- 인접 행렬 표현: 7.5절 / 9.4절 등...
- 인접 리스트 표현: 3.6절 / 4.2절 등...

<br>

## 트리 용어
![image](https://user-images.githubusercontent.com/79950504/188537017-78a0a6be-9c67-427f-9a49-71875b902e18.png)

#### 트리의 표현
- 일반트리
- 이진트리 (배열구조 / 연결된 구조)

<br>

## 집합
![image](https://user-images.githubusercontent.com/79950504/188537122-50fa3db7-d319-41ea-bfac-af829c9334dc.png)
- 원소들 사이에 순서가 없고 중복을 허용하지 않음.
- 선형 자료구조가 아님.
- 위치가 없음.

#### 파이썬의 집합
![image](https://user-images.githubusercontent.com/79950504/188537153-6f58782c-58ba-4b3b-856a-606903758ed3.png)

<br>

## 맵 / 딕셔너리
- 탐색을 위한 자료구조.
- 키를 가진 레코드 또는 엔트리의 집합.

#### 엔트리 (Entry)
- 키: 영어 단어와 같은 레코드를 구분할 수 있는 탐색키.
- 값: 영어 단어의 의미와 같이 탐색키와 관련된 정보들.

#### 파이썬의 딕셔너리
![image](https://user-images.githubusercontent.com/79950504/188537337-5bc16092-29b6-440b-beb3-9001e0fdd9eb.png)










